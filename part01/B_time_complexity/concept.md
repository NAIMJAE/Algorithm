## 시간복잡도
- 입력 크기와 알고리즘간의 관계
- 알고리즘의 복잡도를 나타내는 지표 중 하나
- 입력 크기에 대해 프로그램의 동작 시간을 가늠할 수 있는 수단
- Big-O / Big-Omega / Big-Theta 와 같은 표기법으로 나타낼 수 있음

### Big-O
- 정의된 입력 데이터 중 가장 최악의 상황을 포함한 시간의 상한선

### 배열의 시간복잡도
※ get(int idx) : idx번째 원소 반환
- 메모리가 연속적이기 때문에 배열의 시작 주소로부터 idx만큼 떨어진 원소의 주소를 바로 계산하고 접근 가능
- 따라서 get(int idx)의 시간복잡도는 O(1)

※ change(int idx, int val) : idx번째 원소를 val로 변경
- idx번 원소에 바로 접근하고, 값을 변경 가능
- 따라서 change(int idx, int val)의 시간복잡도는 O(1)

※ append(int val) : 가장 뒤에 val 원소를 삽입
- 현재 배열에 담긴 원소의 개수를 알면 해당 인덱스에 요청받은 원소를 바로 넣을 수 있음
- 하지만 빈 공간이 없는 배열이라면, 새로운 배열을 생성해 옮겨담아야 함
- 하지만 단순 상수 계산으로 해결 가능하기에 append(int val)의 시간복잡도는 O(1)

※ insert(int idx, int val) : idx번째 원소의 앞에 val 원소를 삽입
- 연속된 배열의 중간에 새로운 원소를 추가하기 위해서는 추가되는 원소의 뒷 원소들이 모두 한 칸씩 뒤로 이동
- 원소들을 한 칸씩 뒤로 이동시키기 위해서는 반복문이 필요
- 따라서 insert(int idx, int val)의 시간복잡도는 O(N)

※ erase(int idx) : idx번째 원소를 삭제
- 연속된 배열의 중간 원소를 삭제하기 위해서는 해당 원소의 뒷 원소들을 모두 한 칸씩 앞으로 이동
- 원소들을 한 칸씩 앞으로 이동시키기 위해서는 반복문이 필요
- 따라서 erase(int idx)의 시간복잡도는 O(N)

